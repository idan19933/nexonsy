// server/ai-proxy.js - SMART TOPIC-BASED QUESTION GENERATION
import { formatMathAnswer, compareMathExpressions } from './utils/mathFormatter.js';
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import multer from 'multer';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import personalitySystem from './services/personalityLoader.js';
import questionHistoryManager from './services/questionHistory.js';
import SVGGenerator from './services/svgGenerator.js';
import { bucket } from './config/firebase-admin.js';
import nexonRoutes from './routes/nexonRoutes.js';
import notebookService from './services/notebookService.js';
import notebookRoutes from './routes/notebookRoutes.js';
import userRoutes from './routes/userRoutes.js';
import curriculumRoutes from './routes/curriculumRoutes.js';
import learningRoutes from './routes/learningRoutes.js';


import ISRAELI_CURRICULUM, {
    getGradeConfig,
    getReformNotes,
    getExamInfo,
    getClusters,
    getPedagogicalNote,
    CURRICULUM_METADATA
} from './config/israeliCurriculum.js';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3001;

app.use(cors());
app.use(express.json({ limit: '50mb' }));

// ==================== MULTER CONFIGURATION ====================
// ==================== MULTER CONFIGURATION - ENHANCED ====================
const storage = multer.memoryStorage();

const upload = multer({
    storage,
    limits: {
        fileSize: 10 * 1024 * 1024 // 10MB limit
    },
    fileFilter: (req, file, cb) => {
        console.log('üìÅ File upload attempt:');
        console.log('   Original name:', file.originalname);
        console.log('   MIME type:', file.mimetype);

        // Check if it's an Excel file
        const isExcel = file.originalname.toLowerCase().endsWith('.xlsx') ||
            file.originalname.toLowerCase().endsWith('.xls');

        const excelMimeTypes = [
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            'application/vnd.ms-excel',
            'application/octet-stream',
            'application/zip'
        ];

        // Check if it's an image file
        const isImage = file.mimetype.startsWith('image/');

        const imageMimeTypes = [
            'image/jpeg',
            'image/jpg',
            'image/png',
            'image/webp',
            'image/gif'
        ];

        const validExcel = isExcel || excelMimeTypes.includes(file.mimetype);
        const validImage = isImage || imageMimeTypes.includes(file.mimetype);

        if (validExcel || validImage) {
            console.log('   ‚úÖ File accepted');
            cb(null, true);
        } else {
            console.log('   ‚ùå File rejected');
            cb(new Error('Only Excel and Image files allowed!'), false);
        }
    }
});

// ==================== HELPER: CLEAN JSON ====================
// ==================== HELPER: CLEAN JSON - ENHANCED ====================
function cleanJsonText(rawText) {
    let jsonText = rawText.trim();

    // Remove markdown code blocks
    if (jsonText.startsWith('```json')) {
        jsonText = jsonText.replace(/```json\n?/g, '').replace(/```\n?$/g, '');
    } else if (jsonText.startsWith('```')) {
        jsonText = jsonText.replace(/```\n?/g, '');
    }

    // Find JSON boundaries
    const jsonStart = jsonText.indexOf('{');
    const jsonEnd = jsonText.lastIndexOf('}') + 1;

    if (jsonStart !== -1 && jsonEnd > jsonStart) {
        jsonText = jsonText.substring(jsonStart, jsonEnd);
    }

    // üî• FIX 1: Remove control characters EXCEPT newlines in specific contexts
    jsonText = jsonText
        .replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F-\u009F]/g, '');

    // üî• FIX 2: Fix newlines inside string values
    // This regex finds strings and replaces \n with \\n inside them
    jsonText = jsonText.replace(
        /"([^"\\]|\\.)*"/g,
        match => match.replace(/\n/g, '\\n').replace(/\r/g, '\\r')
    );

    // üî• FIX 3: Fix common JSON syntax errors
    jsonText = jsonText
        // Fix trailing commas before } or ]
        .replace(/,(\s*[}\]])/g, '$1')
        // Fix missing commas between properties (common Claude error)
        .replace(/("\s*:\s*"[^"]*")\s*("\w+"\s*:)/g, '$1,$2')
        .replace(/("\s*:\s*\d+)\s*("\w+"\s*:)/g, '$1,$2')
        .replace(/("\s*:\s*true|false)\s*("\w+"\s*:)/g, '$1,$2')
        // Fix unescaped quotes in Hebrew text
        .replace(/:\\s*"([^"]*?)"([^,}\]]*?)"/g, (match, p1, p2) => {
            if (p2.includes('"')) {
                return `: "${p1}\\"${p2}"`;
            }
            return match;
        });

    // üî• FIX 4: Validate and repair structure
    try {
        // Try to parse - if it works, return as-is
        JSON.parse(jsonText);
        return jsonText;
    } catch (e) {
        console.log('‚ö†Ô∏è JSON still invalid, attempting deep repair...');
        console.log('   Error:', e.message);
        console.log('   Position:', e.message.match(/position (\d+)/)?.[1]);

        // Log the problematic area
        const errorPos = parseInt(e.message.match(/position (\d+)/)?.[1] || '0');
        if (errorPos > 0) {
            const start = Math.max(0, errorPos - 50);
            const end = Math.min(jsonText.length, errorPos + 50);
            console.log('   Context:', jsonText.substring(start, end));
        }

        // Last resort: Try to fix specific common patterns
        jsonText = jsonText
            // Fix Hebrew quotes that break JSON
            .replace(/◊¥/g, '\\"')
            .replace(/◊≥/g, "'")
            // Fix double quotes in values
            .replace(/"([^"]*)"([^"]*?)"/g, (match, p1, p2) => {
                if (p2.includes(':') || p2.includes(',') || p2.includes('}')) {
                    return `"${p1}"${p2}`;
                }
                return `"${p1}${p2.replace(/"/g, '\\"')}"`;
            });

        return jsonText;
    }
}

// ==================== TOPIC CLASSIFICATION SYSTEM ====================
function classifyTopic(topicName, subtopicName) {
    const topic = String(topicName || '').toLowerCase();
    const subtopic = String(subtopicName || '').toLowerCase();

    const isPureGeometry = (
        (topic.includes('◊í◊ê◊ï◊û◊ò◊®◊ô◊î') || topic.includes('geometry')) &&
        (subtopic.includes('◊†◊ß◊ï◊ì◊ï◊™') || subtopic.includes('◊ß◊ï◊ï◊ô◊ù') ||
            subtopic.includes('◊û◊ô◊©◊ï◊®◊ô◊ù') || subtopic.includes('points') ||
            subtopic.includes('lines') || subtopic.includes('planes'))
    );

    const isAppliedGeometry = (
        (topic.includes('◊í◊ê◊ï◊û◊ò◊®◊ô◊î') || topic.includes('geometry')) &&
        (subtopic.includes('◊û◊©◊ï◊ú◊©') || subtopic.includes('◊®◊ô◊ë◊ï◊¢') ||
            subtopic.includes('◊û◊¢◊í◊ú') || subtopic.includes('◊©◊ò◊ó') ||
            subtopic.includes('◊î◊ô◊ß◊£') || subtopic.includes('triangle') ||
            subtopic.includes('rectangle') || subtopic.includes('circle') ||
            subtopic.includes('area') || subtopic.includes('perimeter'))
    );

    const isStatistics = (
        topic.includes('◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊î') || topic.includes('statistics') ||
        topic.includes('◊í◊®◊§◊ô◊ù') || topic.includes('graphs') ||
        subtopic.includes('◊§◊ô◊ñ◊ï◊®') || subtopic.includes('scatter') ||
        subtopic.includes('◊®◊ë◊¢◊ï◊ü') || subtopic.includes('quartile')
    );

    const isAlgebra = (
        topic.includes('◊ê◊ú◊í◊ë◊®◊î') || topic.includes('algebra') ||
        subtopic.includes('◊û◊©◊ï◊ï◊ê◊ï◊™') || subtopic.includes('equations')
    );

    return {
        isPureGeometry,
        isAppliedGeometry,
        isStatistics,
        isAlgebra,
        allowsRealWorld: !isPureGeometry,
        requiresAbstract: isPureGeometry,
        requiresData: isStatistics
    };
}

// ==================== CURRICULUM-AWARE CONTEXT BUILDER ====================
function buildCurriculumContext(gradeId, topic, subtopic) {
    const gradeConfig = getGradeConfig(gradeId);
    if (!gradeConfig) return '';

    let context = `\nüìö CURRICULUM CONTEXT (◊™◊©◊§"◊î Reform):\n`;
    context += `Grade: ${gradeConfig.name} (${gradeConfig.nameEn})\n`;

    if (gradeConfig.implementationYear) {
        context += `Reform Year: ${gradeConfig.implementationYear}\n`;
    }

    const reformNotes = getReformNotes(gradeId);
    if (reformNotes) {
        if (reformNotes.emphasis) {
            context += `\nüéØ Pedagogical Emphasis:\n`;
            reformNotes.emphasis.forEach(e => context += `  - ${e}\n`);
        }
        if (reformNotes.removed) {
            context += `\n‚ùå Excluded Topics:\n`;
            reformNotes.removed.forEach(r => context += `  - ${r}\n`);
        }
    }

    const clusters = getClusters(gradeId);
    if (clusters) {
        context += `\nüé® Learning Clusters:\n`;
        clusters.forEach(c => {
            context += `  - ${c.name}: ${c.description}\n`;
        });
    }

    const topicId = topic?.id || '';
    if (topicId) {
        const pedNote = getPedagogicalNote(gradeId, topicId);
        if (pedNote) {
            context += `\nüìù Topic Note: ${pedNote}\n`;
        }
    }

    if (subtopic) {
        const subtopicName = subtopic.name || '';
        if (subtopicName) {
            context += `\nüîç Specific Subtopic: ${subtopicName}\n`;
            if (subtopic.note) {
                context += `   Note: ${subtopic.note}\n`;
            }
        }
    }

    context += `\n`;
    return context;
}

// ==================== ENHANCED SYSTEM PROMPT ====================
function buildEnhancedSystemPrompt(studentProfile, gradeId, topic, subtopic) {
    const { grade, mathFeeling } = studentProfile || {};

    let prompt = '';

    // Personality
    if (personalitySystem.loaded) {
        const personality = personalitySystem.data.corePersonality;
        prompt += `◊ê◊™◊î ${personality.teacher_name}, ${personality.description}.\n`;
        prompt += `${personality.teaching_approach}\n\n`;
    } else {
        prompt += `◊ê◊™◊î ◊†◊ß◊°◊ï◊ü, ◊û◊ï◊®◊î ◊ì◊ô◊í◊ô◊ò◊ú◊ô ◊ú◊û◊™◊û◊ò◊ô◊ß◊î.\n\n`;
    }

    // Student context
    if (grade) {
        prompt += `◊î◊™◊ú◊û◊ô◊ì ◊ë◊õ◊ô◊™◊î ${grade}.\n`;
    }

    if (mathFeeling === 'struggle') {
        prompt += `◊î◊™◊ú◊û◊ô◊ì ◊û◊™◊ß◊©◊î - ◊î◊ô◊î ◊°◊ë◊ú◊†◊ô ◊û◊ê◊ï◊ì, ◊™◊ü ◊î◊°◊ë◊®◊ô◊ù ◊¶◊¢◊ì-◊¶◊¢◊ì.\n`;
    } else if (mathFeeling === 'love') {
        prompt += `◊î◊™◊ú◊û◊ô◊ì ◊ê◊ï◊î◊ë ◊û◊™◊û◊ò◊ô◊ß◊î - ◊ê◊™◊í◊® ◊ê◊ï◊™◊ï!\n`;
    }

    // üî• CRITICAL: Core principles
    prompt += `\nüéØ ◊¢◊ß◊®◊ï◊†◊ï◊™ ◊ó◊ï◊ë◊î:\n`;
    prompt += `‚úì ◊ô◊¶◊ï◊® ◊©◊ê◊ú◊ï◊™ ◊ô◊ô◊ó◊ï◊ì◊ô◊ï◊™ ◊ï◊û◊í◊ï◊ï◊†◊ï◊™\n`;
    prompt += `‚úì ◊¢◊ß◊ï◊ë ◊ê◊ó◊® ◊™◊õ◊†◊ô◊™ ◊î◊ú◊ô◊û◊ï◊ì◊ô◊ù ◊î◊ô◊©◊®◊ê◊ú◊ô◊™ (◊™◊©◊§"◊î)\n`;
    prompt += `‚úì ◊î◊©◊™◊û◊© ◊ë◊¢◊ë◊®◊ô◊™ ◊ë◊®◊ï◊®◊î ◊ï◊ò◊ë◊¢◊ô◊™\n`;
    prompt += `‚úì ◊î◊ó◊ñ◊® JSON ◊™◊ß◊ô◊ü ◊ë◊ú◊ë◊ì\n`;
    prompt += `‚úì ◊ê◊ú ◊™◊ó◊ñ◊ï◊® ◊¢◊ú ◊©◊ê◊ú◊ï◊™ ◊ß◊ï◊ì◊û◊ï◊™\n`;
    prompt += `‚úì ◊õ◊ú ◊©◊ê◊ú◊î = ◊ó◊ï◊ï◊ô◊ô◊î ◊ó◊ì◊©◊î\n\n`;

    return prompt;
}

// ==================== VALIDATE QUESTION HAS RAW DATA ====================
function validateQuestionHasRawData(parsed, topic, subtopic) {
    const questionText = parsed?.question || '';

    if (!questionText || typeof questionText !== 'string') {
        return { valid: true };
    }

    const graphTopics = [
        '◊§◊ï◊†◊ß◊¶◊ô◊ï◊™', '◊í◊®◊§◊ô◊ù', 'Functions', 'Graphs',
        '◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊î', 'Statistics', '◊†◊™◊ï◊†◊ô◊ù', 'Data',
        '◊§◊ô◊ñ◊ï◊®', 'Scatter', '◊®◊ë◊¢◊ï◊†◊ô◊ù', 'Quartiles',
        '◊™◊ó◊ï◊ù ◊ë◊ô◊ü-◊®◊ë◊¢◊ï◊†◊ô', 'IQR', '◊î◊ô◊°◊ò◊ï◊í◊®◊û◊î', 'Histogram'
    ];

    const topicName = String(topic?.name || '');
    const topicNameEn = String(topic?.nameEn || '');
    const subtopicName = String(subtopic?.name || '');
    const subtopicNameEn = String(subtopic?.nameEn || '');

    const needsGraph = graphTopics.some(t =>
        topicName.includes(t) ||
        topicNameEn.includes(t) ||
        subtopicName.includes(t) ||
        subtopicNameEn.includes(t)
    );

    if (!needsGraph) {
        return { valid: true };
    }

    console.log('üîç Validating question has raw data...');

    const forbiddenPatterns = [
        /◊û◊û◊ï◊¶◊¢.*◊î◊ï◊ê/,
        /◊û◊û◊ï◊¶◊¢.*◊î◊õ◊ú◊ú◊ô/,
        /◊†◊¢ ◊ë◊ô◊ü.*\d+-\d+/,
        /◊í◊®◊£.*◊û◊®◊ê◊î/,
        /◊í◊®◊£.*◊û◊¶◊ô◊í/,
        /◊î◊í◊®◊£.*◊©◊ú◊ï.*◊û◊¶◊ô◊í/,
        /◊î◊í◊®◊£.*◊©◊ú◊§◊†◊ô◊õ◊ù/,
        /◊ë◊í◊®◊£.*◊©◊ú◊§◊†◊ô◊õ◊ù/,
        /◊í◊®◊£.*◊î◊§◊ô◊ñ◊ï◊®.*◊©◊ú◊§◊†◊ô◊õ◊ù/,
        /◊™◊®◊©◊ô◊ù.*◊û◊¶◊ô◊í/,
        /◊ò◊ë◊ú◊î.*◊û◊¶◊ô◊í◊î/,
        /◊î◊ß◊©◊® ◊ë◊ô◊ü/,
        /◊û◊™◊ï◊ê◊®.*◊í◊®◊£/,
        /◊û◊ï◊¶◊í◊ï◊™.*◊ë◊í◊®◊£/,
        /◊û◊ï◊§◊ô◊¢◊ô◊ù.*◊ë◊í◊®◊£/,
        /◊î◊™◊ï◊¶◊ê◊ï◊™.*◊û◊ï◊¶◊í◊ï◊™/,
        /◊î◊†◊™◊ï◊†◊ô◊ù.*◊û◊ï◊¶◊í◊ô◊ù/,
        /◊†◊™◊ï◊†◊ô◊ù.*◊ê◊ú◊î.*◊û◊ï◊¶◊í◊ô◊ù/,
        /◊û◊ï◊¶◊í◊ô◊ù.*◊ë◊í◊®◊£.*◊§◊ô◊ñ◊ï◊®/,
        /◊†◊™◊ï◊†◊ô.*◊î◊°◊ß◊®.*◊û◊®◊ê◊ô◊ù/,
        /◊†◊™◊ï◊†◊ô◊ù.*◊ê◊ú◊î/i,
        /◊ú◊î◊ú◊ü.*◊î◊†◊™◊ï◊†◊ô◊ù/i,
        /◊ë◊í◊®◊£.*◊î◊ë◊ê/,
        /◊ë◊í◊®◊£.*◊î◊§◊ô◊ñ◊ï◊®.*◊î◊ë◊ê/,
        /◊©◊ù.*◊î◊™◊ú◊û◊ô◊ì.*\|/,
        /\d+-\d+\s*\|/,
        /\d+\+\s*\|/,
        /◊ò◊ë◊ú◊î.*◊î◊ë◊ê◊î/,
        /\|.*\|.*\|/,
        /[◊ê-◊™]+\s*\d*\s*:\s*\d+\s*◊©◊¢◊ï◊™/i,
        /◊™◊ú◊û◊ô◊ì\s*\d+\s*:\s*\d+/i,
        /[◊ê-◊™]+:\s*\d+\s*◊©◊¢◊ï◊™,\s*[◊ê-◊™]+:\s*\d+\s*◊©◊¢◊ï◊™/
    ];

    const hasForbiddenPattern = forbiddenPatterns.some(pattern =>
        pattern.test(questionText)
    );

    if (hasForbiddenPattern) {
        console.log('‚ùå Question has FORBIDDEN pattern');
        return {
            valid: false,
            reason: 'Contains forbidden patterns'
        };
    }

    const hasTwoLabeledLists = /\(x\)\s*:\s*[0-9,\s]+/i.test(questionText) &&
        /\(y\)\s*:\s*[0-9,\s]+/i.test(questionText);

    if (hasTwoLabeledLists) {
        console.log('‚úÖ Question has TWO labeled lists');
        return { valid: true };
    }

    const commaNumbers = questionText.match(/\d+(?:\.\d+)?(?:\s*,\s*\d+(?:\.\d+)?){9,}/g);

    if (commaNumbers && commaNumbers.length > 0) {
        console.log('‚úÖ Question has comma-separated numbers');
        return { valid: true };
    }

    console.log('‚ùå Question does NOT have proper raw data');
    return {
        valid: false,
        reason: 'Missing proper data format'
    };
}

// ==================== FORCE REWRITE ====================
function forceRewriteGraphDescription(parsed, topic, subtopic) {
    const questionText = parsed?.question || '';

    if (!questionText || typeof questionText !== 'string') {
        return parsed;
    }

    const forbiddenPatterns = [
        /◊î◊í◊®◊£.*◊û◊¶◊ô◊í/i,
        /◊î◊™◊®◊©◊ô◊ù.*◊û◊¶◊ô◊í/i,
        /◊î◊í◊®◊£.*◊û◊®◊ê◊î/i,
        /◊î◊™◊ï◊¶◊ê◊ï◊™.*◊û◊ï◊¶◊í◊ï◊™/i,
        /◊î◊†◊™◊ï◊†◊ô◊ù.*◊û◊ï◊¶◊í◊ô◊ù/i,
        /◊†◊™◊ï◊†◊ô◊ù.*◊ê◊ú◊î.*◊û◊ï◊¶◊í◊ô◊ù/i,
        /◊†◊™◊ï◊†◊ô.*◊î◊°◊ß◊®.*◊û◊®◊ê◊ô◊ù/i,
        /◊†◊™◊ï◊†◊ô◊ù.*◊ê◊ú◊î/i,
        /◊ú◊î◊ú◊ü.*◊î◊†◊™◊ï◊†◊ô◊ù/i,
        /◊î◊í◊®◊£.*◊©◊ú◊ï.*◊û◊¶◊ô◊í/i,
        /◊û◊ï◊¶◊í◊ô◊ù.*◊ë◊í◊®◊£.*◊§◊ô◊ñ◊ï◊®/i
    ];

    const hasGraphDescription = forbiddenPatterns.some(pattern => pattern.test(questionText));

    const anyLabelPattern = /([◊ê-◊™]+\s*\d*)\s*:\s*(\d+)\s*◊©◊¢◊ï◊™/g;
    const anyLabelMatches = [...questionText.matchAll(anyLabelPattern)];
    const hasLabelValueFormat = anyLabelMatches.length >= 3;

    if (!hasGraphDescription && !hasLabelValueFormat) {
        return parsed;
    }

    console.log('üö® FORCING COMPLETE REWRITE');

    const questionLower = questionText.toLowerCase();
    const isSport = questionLower.includes('◊°◊§◊ï◊®◊ò') || questionLower.includes('◊ó◊ï◊í');
    const isGrades = questionLower.includes('◊¶◊ô◊ï◊ü');

    const numPoints = 20 + Math.floor(Math.random() * 4);
    const xValues = [];
    const yValues = [];

    let rewrittenQuestion = '';
    let xLabel = 'X';
    let yLabel = 'Y';

    if (isSport && isGrades) {
        for (let i = 0; i < numPoints; i++) {
            xValues.push(Math.floor(1 + Math.random() * 7));
            yValues.push(Math.floor(65 + Math.random() * 30));
        }

        rewrittenQuestion = `◊†◊ê◊°◊§◊ï ◊†◊™◊ï◊†◊ô◊ù ◊¢◊ú ${numPoints} ◊™◊ú◊û◊ô◊ì◊ô◊ù - ◊û◊°◊§◊® ◊©◊¢◊ï◊™ ◊°◊§◊ï◊®◊ò ◊©◊ë◊ï◊¢◊ô◊ï◊™ ◊ï◊î◊¶◊ô◊ï◊ü ◊ë◊û◊™◊û◊ò◊ô◊ß◊î:

◊©◊¢◊ï◊™ ◊°◊§◊ï◊®◊ò ◊©◊ë◊ï◊¢◊ô◊ï◊™ (x): ${xValues.join(', ')}
◊¶◊ô◊ï◊ü ◊ë◊û◊™◊û◊ò◊ô◊ß◊î (y): ${yValues.join(', ')}

◊¶◊®◊ï ◊í◊®◊£ ◊§◊ô◊ñ◊ï◊® ◊ï◊î◊°◊ë◊ô◊®◊ï ◊û◊î ◊†◊ô◊™◊ü ◊ú◊ú◊û◊ï◊ì ◊¢◊ú ◊î◊ß◊©◊® ◊ë◊ô◊ü ◊î◊û◊©◊™◊†◊ô◊ù.`;

        xLabel = '◊©◊¢◊ï◊™ ◊°◊§◊ï◊®◊ò';
        yLabel = '◊¶◊ô◊ï◊ü ◊ë◊û◊™◊û◊ò◊ô◊ß◊î';

    } else {
        for (let i = 0; i < numPoints; i++) {
            xValues.push(Math.floor(10 + Math.random() * 40));
            yValues.push(Math.floor(50 + Math.random() * 50));
        }

        rewrittenQuestion = `◊†◊™◊ï◊†◊ï◊™ ${numPoints} ◊†◊ß◊ï◊ì◊ï◊™ ◊¢◊ù ◊©◊†◊ô ◊û◊©◊™◊†◊ô◊ù:

◊û◊©◊™◊†◊î X: ${xValues.join(', ')}
◊û◊©◊™◊†◊î Y: ${yValues.join(', ')}

◊¶◊®◊ï ◊í◊®◊£ ◊§◊ô◊ñ◊ï◊® ◊ï◊ß◊ë◊¢◊ï ◊ê◊™ ◊°◊ï◊í ◊î◊û◊™◊ê◊ù ◊ë◊ô◊ü ◊î◊û◊©◊™◊†◊ô◊ù.`;

        xLabel = 'X';
        yLabel = 'Y';
    }

    const points = xValues.map((x, idx) => ({
        x: x,
        y: yValues[idx],
        label: `◊†◊ß◊ï◊ì◊î ${idx + 1}`
    }));

    const visualData = {
        type: 'scatter',
        points: points,
        xRange: [Math.min(...xValues) - 2, Math.max(...xValues) + 2],
        yRange: [Math.min(...yValues) - 2, Math.max(...yValues) + 2],
        color: '#9333ea',
        label: '◊í◊®◊£ ◊§◊ô◊ñ◊ï◊®',
        xLabel: xLabel,
        yLabel: yLabel
    };

    parsed.question = rewrittenQuestion;
    parsed.visualData = visualData;

    console.log('‚úÖ Question REWRITTEN');
    return parsed;
}

// ==================== VISUAL DATA EXTRACTION ====================
function ensureVisualDataForGraphQuestions(parsed, topic, subtopic) {
    try {
        const questionText = parsed?.question || '';

        if (!questionText || typeof questionText !== 'string') {
            console.log('‚ö†Ô∏è Invalid question text');
            return parsed;
        }

        console.log('\nüî•üî•üî• EXTRACTION V2 STARTING üî•üî•üî•');
        console.log('Question (first 200):', questionText.substring(0, 200));
        console.log('AI visualData:', parsed.visualData ? 'EXISTS' : 'NULL');

        if (parsed.visualData && (parsed.visualData.data?.length > 0 || parsed.visualData.points?.length > 0)) {
            console.log('‚úÖ visualData already complete');
            return parsed;
        }

        console.log('\nüîé METHOD 1: X-Y labeled lists');

        const patterns = [
            { x: /([^\n:]+?)\s*\(x\)\s*:\s*([0-9,\s.]+)/i, y: /([^\n:]+?)\s*\(y\)\s*:\s*([0-9,\s.]+)/i },
            { x: /([^\n:]+?)\s*\(x\)\s*\:\s*([0-9,\s.]+)/i, y: /([^\n:]+?)\s*\(y\)\s*\:\s*([0-9,\s.]+)/i },
            { x: /([◊ê-◊™\s]+)\(x\)\s*:\s*([0-9,\s.]+)/i, y: /([◊ê-◊™\s]+)\(y\)\s*:\s*([0-9,\s.]+)/i }
        ];

        for (let i = 0; i < patterns.length; i++) {
            const xMatch = questionText.match(patterns[i].x);
            const yMatch = questionText.match(patterns[i].y);

            if (xMatch && yMatch) {
                console.log(`‚úì Pattern ${i + 1} matched!`);

                const xLabel = xMatch[1].trim();
                const yLabel = yMatch[1].trim();

                const xValues = xMatch[2]
                    .split(/[,ÿå\s]+/)
                    .map(n => parseFloat(n.trim()))
                    .filter(n => !isNaN(n) && isFinite(n));

                const yValues = yMatch[2]
                    .split(/[,ÿå\s]+/)
                    .map(n => parseFloat(n.trim()))
                    .filter(n => !isNaN(n) && isFinite(n));

                console.log(`   X: ${xValues.length} values ‚Üí`, xValues.slice(0, 5));
                console.log(`   Y: ${yValues.length} values ‚Üí`, yValues.slice(0, 5));

                if (xValues.length >= 4 && yValues.length >= 4) {
                    const minLength = Math.min(xValues.length, yValues.length);
                    const points = xValues.slice(0, minLength).map((x, idx) => ({
                        x: x,
                        y: yValues[idx],
                        label: `◊†◊ß◊ï◊ì◊î ${idx + 1}`
                    }));

                    const visualData = {
                        type: 'scatter',
                        points: points,
                        xRange: [Math.min(...xValues.slice(0, minLength)) - 1, Math.max(...xValues.slice(0, minLength)) + 1],
                        yRange: [Math.min(...yValues.slice(0, minLength)) - 1, Math.max(...yValues.slice(0, minLength)) + 1],
                        color: '#9333ea',
                        label: '◊í◊®◊£ ◊§◊ô◊ñ◊ï◊®',
                        xLabel: xLabel,
                        yLabel: yLabel
                    };

                    console.log('‚úÖ‚úÖ‚úÖ SUCCESS! Scatter plot created');
                    console.log('üî•üî•üî• EXTRACTION COMPLETE üî•üî•üî•\n');
                    return { ...parsed, visualData };
                }
            }
        }

        console.log('‚ö†Ô∏è Could not extract any valid data');
        console.log('üî•üî•üî• EXTRACTION FAILED üî•üî•üî•\n');

    } catch (error) {
        console.error('‚ùå EXTRACTION ERROR:', error.message);
    }

    return parsed;
}

// ==================== DETECT GEOMETRY QUESTIONS ====================
// ==================== DETECT GEOMETRY QUESTIONS - FIXED ====================
// ==================== DETECT GEOMETRY QUESTIONS - FIXED V2 ====================
// ==================== DETECT GEOMETRY QUESTIONS - FIXED V3 WITH HEIGHT FILTERING ====================
// ==================== DETECT GEOMETRY QUESTIONS - COMPLETE FIXED VERSION ====================
function detectGeometryVisual(parsed, topic, subtopic) {
    const questionText = (parsed?.question || '').toLowerCase();

    if (!questionText || typeof questionText !== 'string') {
        return parsed;
    }

    const geometryKeywords = [
        '◊û◊©◊ï◊ú◊©', 'triangle', '◊®◊ô◊ë◊ï◊¢', 'square', '◊û◊ú◊ë◊ü', 'rectangle',
        '◊¢◊ô◊í◊ï◊ú', 'circle', '◊û◊¢◊í◊ú', '◊ñ◊ï◊ï◊ô◊™', 'angle', '◊¶◊ú◊¢', 'side',
        '◊†◊ô◊¶◊ë', 'right', '◊©◊ï◊ï◊î ◊¶◊ú◊¢◊ï◊™', 'equilateral', '◊î◊ô◊ß◊£', 'perimeter',
        '◊©◊ò◊ó', 'area', '◊®◊ì◊ô◊ï◊°', 'radius', '◊ß◊ï◊ò◊®', 'diameter',
        '◊©◊ï◊ï◊î ◊©◊ï◊ß◊ô◊ô◊ù', 'isosceles', '◊©◊ï◊ß◊ô◊ô◊ù', '◊©◊ï◊ï◊î-◊©◊ï◊ß◊ô◊ô◊ù'
    ];

    const isGeometry = geometryKeywords.some(keyword => questionText.includes(keyword));
    if (!isGeometry) return parsed;

    console.log('üî∫ Geometry question detected');
    console.log('   Question:', parsed.question);

    // üî• STEP 1: Extract and exclude angles
    const anglePatterns = [
        /◊ñ◊ï◊ï◊ô◊™.*?(\d+)¬∞/gi,
        /◊ñ◊ï◊ï◊ô◊™.*?(\d+)\s*◊û◊¢◊ú◊ï◊™/gi,
        /(\d+)¬∞/g,
        /angle.*?(\d+)/gi
    ];

    const angleNumbers = new Set();
    anglePatterns.forEach(pattern => {
        let match;
        const regex = new RegExp(pattern);
        while ((match = regex.exec(parsed.question)) !== null) {
            angleNumbers.add(parseFloat(match[1]));
        }
    });
    console.log('   üö´ Angles to exclude:', Array.from(angleNumbers));

    // üî• STEP 2: Extract and exclude height
    const heightPatterns = [
        /◊í◊ï◊ë◊î.*?(\d+)/gi,
        /height.*?(\d+)/gi
    ];

    const heightNumbers = new Set();
    heightPatterns.forEach(pattern => {
        let match;
        const regex = new RegExp(pattern);
        while ((match = regex.exec(parsed.question)) !== null) {
            heightNumbers.add(parseFloat(match[1]));
        }
    });
    console.log('   üö´ Heights to exclude:', Array.from(heightNumbers));

    // üî• STEP 3: Extract ALL numbers, then filter out angles and heights
    const allNumbers = (parsed.question || '')
        .match(/\d+(\.\d+)?/g)
        ?.map(n => parseFloat(n))
        .filter(n => !angleNumbers.has(n) && !heightNumbers.has(n) && n > 0 && n < 1000) || [];

    console.log('   ‚úÖ Valid numbers (after filtering):', allNumbers);

    let visualData = null;

    // ==================== TRIANGLE DETECTION ====================
    if (questionText.includes('◊û◊©◊ï◊ú◊©') || questionText.includes('triangle')) {
        console.log('   ‚Üí Triangle detected');

        // Detect triangle type
        const isRight = questionText.includes('◊†◊ô◊¶◊ë') || questionText.includes('right') ||
            questionText.includes('◊ô◊©◊®-◊ñ◊ï◊ï◊ô◊™') || questionText.includes('◊ô◊©◊® ◊ñ◊ï◊ï◊ô◊™');
        const isEquilateral = questionText.includes('◊©◊ï◊ï◊î ◊¶◊ú◊¢◊ï◊™') || questionText.includes('equilateral');
        const isIsosceles = questionText.includes('◊©◊ï◊ï◊î ◊©◊ï◊ß◊ô◊ô◊ù') || questionText.includes('◊©◊ï◊ï◊î-◊©◊ï◊ß◊ô◊ô◊ù') ||
            questionText.includes('isosceles') || questionText.includes('◊©◊ï◊ß◊ô◊ô◊ù');

        let type = 'scalene';
        if (isRight) type = 'right';
        else if (isEquilateral) type = 'equilateral';
        else if (isIsosceles) type = 'isosceles';

        console.log('   Triangle type:', type);

        let sideA, sideB, sideC;

        // üî• ENHANCED ISOSCELES EXTRACTION
        if (isIsosceles) {
            console.log('   ‚Üí Processing ISOSCELES triangle');

            // üî• METHOD 1: Look for explicit "◊ë◊°◊ô◊°" and "◊©◊ï◊ß◊ô◊ô◊ù" keywords
            const basePatterns = [
                /(?:◊ê◊ï◊®◊ö\s+◊î?)?◊ë◊°◊ô◊°(?:\s+◊î◊ï◊ê)?\s+(\d+)/i,
                /◊ë◊°◊ô◊°\s+(\d+)/i,
                /base\s+(\d+)/i
            ];

            const legPatterns = [
                /(?:◊ê◊ï◊®◊ö\s+◊î?)?◊©◊ï◊ß◊ô◊ô◊ù(?:\s+◊î◊ï◊ê)?\s+(\d+)/i,
                /◊©◊ï◊ß◊ô◊ô◊ù\s+(\d+)/i,
                /legs?\s+(\d+)/i
            ];

            let base = null;
            let leg = null;

            // Try to find base
            for (const pattern of basePatterns) {
                const match = parsed.question.match(pattern);
                if (match) {
                    base = parseFloat(match[1]);
                    console.log('   ‚úÖ Found BASE from keyword:', base);
                    break;
                }
            }

            // Try to find legs
            for (const pattern of legPatterns) {
                const match = parsed.question.match(pattern);
                if (match) {
                    leg = parseFloat(match[1]);
                    console.log('   ‚úÖ Found LEGS from keyword:', leg);
                    break;
                }
            }

            // üî• METHOD 2: Fallback - use position in filtered numbers
            if (!base || !leg) {
                console.log('   ‚Üí Using fallback method');

                if (allNumbers.length >= 2) {
                    // First number is usually base, second is legs
                    base = allNumbers[0];
                    leg = allNumbers[1];
                    console.log('   ‚úÖ Fallback - Base:', base, 'Legs:', leg);
                } else if (allNumbers.length === 1) {
                    // Only one number - make equilateral
                    base = allNumbers[0];
                    leg = allNumbers[0];
                    console.log('   ‚ö†Ô∏è Only one number - using equilateral');
                } else {
                    // No numbers - use defaults
                    base = 8;
                    leg = 10;
                    console.log('   ‚ö†Ô∏è No numbers found - using defaults');
                }
            }

            // Ensure we have valid numbers
            if (!angleNumbers.has(base) && !heightNumbers.has(base) &&
                !angleNumbers.has(leg) && !heightNumbers.has(leg)) {
                sideA = base;    // Base (BC)
                sideB = leg;     // Left leg (AB)
                sideC = leg;     // Right leg (AC)
                console.log('   ‚úÖ FINAL ISOSCELES - Base:', sideA, 'Legs:', sideB, sideC);
            } else {
                // Validation failed - use defaults
                sideA = 8;
                sideB = 10;
                sideC = 10;
                console.log('   ‚ö†Ô∏è Validation failed - using defaults');
            }
        }
        // EQUILATERAL
        else if (isEquilateral) {
            sideA = allNumbers[0] || 8;
            sideB = sideA;
            sideC = sideA;
            console.log('   ‚úÖ Equilateral - All sides:', sideA);
        }
        // RIGHT TRIANGLE
        else if (isRight) {
            sideA = allNumbers[0] || 3;
            sideB = allNumbers[1] || 4;
            sideC = allNumbers[2] || 5;
            console.log('   ‚úÖ Right triangle - Sides:', sideA, sideB, sideC);
        }
        // SCALENE
        else {
            sideA = allNumbers[0] || 6;
            sideB = allNumbers[1] || 8;
            sideC = allNumbers[2] || 7;
            console.log('   ‚úÖ Scalene - Sides:', sideA, sideB, sideC);
        }

        console.log('   üìè FINAL TRIANGLE - A:', sideA, 'B:', sideB, 'C:', sideC);

        visualData = {
            type: 'svg-triangle',
            svgData: {
                type: type,
                sideA: sideA,
                sideB: sideB,
                sideC: sideC,
                showLabels: true,
                showAngles: questionText.includes('◊ñ◊ï◊ï◊ô◊™') || questionText.includes('angle')
            }
        };
    }
    // ==================== RECTANGLE ====================
    else if (questionText.includes('◊û◊ú◊ë◊ü') || questionText.includes('rectangle')) {
        const width = allNumbers[0] || 5;
        const height = allNumbers[1] || 3;
        visualData = {
            type: 'svg-rectangle',
            svgData: { width, height, showLabels: true }
        };
    }
    // ==================== CIRCLE ====================
    else if (questionText.includes('◊¢◊ô◊í◊ï◊ú') || questionText.includes('◊û◊¢◊í◊ú') || questionText.includes('circle')) {
        const radius = allNumbers[0] || 5;
        visualData = {
            type: 'svg-circle',
            svgData: { radius, showLabels: true }
        };
    }

    if (visualData) {
        console.log('‚úÖ Visual created:', visualData.type);
        console.log('   üìä Data:', JSON.stringify(visualData.svgData, null, 2));
        parsed.visualData = visualData;
    }

    return parsed;
}

// ==================== HEALTH CHECK ====================
app.get('/health', (req, res) => {
    res.json({
        status: 'ok',
        message: 'Nexon AI Server - Smart Topic-Based Questions',
        personalityLoaded: personalitySystem.loaded,
        curriculumLoaded: true,
        questionHistoryActive: true,
        visualGenerationActive: true,
        reformYear: CURRICULUM_METADATA.reformYear,
        firebaseStorage: bucket ? 'available' : 'unavailable'
    });
});

// ==================== üî• SMART TOPIC-BASED QUESTION PROMPT ====================
// ==================== üî• SMART TOPIC-BASED QUESTION PROMPT ====================
// ==================== üî• SMART TOPIC-BASED QUESTION PROMPT ====================
// ==================== üî• SMART TOPIC-BASED QUESTION PROMPT - COMPLETE ====================
// ==================== üî• COMPLETE buildDynamicQuestionPrompt WITH EXAMPLE FILTERING ====================
function buildDynamicQuestionPrompt(topic, subtopic, difficulty, studentProfile, gradeId) {
    try {
        if (!topic || typeof topic !== 'object') {
            console.error('‚ùå Invalid topic object:', topic);
            throw new Error('Invalid topic object');
        }

        const topicName = String(topic?.name || 'Unknown Topic');
        const subtopicName = String(subtopic?.name || '');
        const studentGrade = String(studentProfile?.grade || '7');

        console.log('‚úÖ Building prompt - Topic:', topicName, '/ Subtopic:', subtopicName);

        const classification = classifyTopic(topicName, subtopicName);

        // üî• FIX 1: START WITH CURRICULUM CONTEXT
        let prompt = buildCurriculumContext(gradeId, topic, subtopic);

        prompt += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
        prompt += `üéØ ◊ô◊¶◊ô◊®◊™ ◊©◊ê◊ú◊î ◊ó◊ì◊©◊î ◊ï◊û◊ß◊ï◊®◊ô◊™\n`;
        prompt += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
        prompt += `◊†◊ï◊©◊ê ◊®◊ê◊©◊ô: ${topicName}\n`;
        if (subtopicName) {
            prompt += `◊™◊™-◊†◊ï◊©◊ê (◊ñ◊î ◊î◊û◊ï◊ß◊ì ◊î◊¢◊ô◊ß◊®◊ô): ${subtopicName}\n`;
            prompt += `‚ö†Ô∏è ◊î◊©◊ê◊ú◊î ◊ó◊ô◊ô◊ë◊™ ◊ú◊î◊ô◊ï◊™ ◊ô◊©◊ô◊®◊ï◊™ ◊¢◊ú "${subtopicName}"\n`;
        }
        prompt += `◊®◊û◊™ ◊ß◊ï◊©◊ô: ${difficulty}\n`;
        prompt += `◊õ◊ô◊™◊î: ${studentGrade}\n`;
        prompt += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

        // üî• FIX 2: SHOW RECENT QUESTIONS PROMINENTLY
        const studentId = studentProfile?.studentId || studentProfile?.name || 'anonymous';
        const topicId = topic?.id || topicName;
        const recentQuestions = questionHistoryManager.getRecentQuestions(studentId, topicId, 10);

        if (recentQuestions && recentQuestions.length > 0) {
            prompt += `üö® ◊ê◊°◊ï◊® ◊ú◊ó◊ñ◊ï◊® ◊¢◊ú ◊©◊ê◊ú◊ï◊™ ◊ß◊ï◊ì◊û◊ï◊™:\n`;
            prompt += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
            recentQuestions.forEach((q, idx) => {
                const preview = q.question.substring(0, 100).replace(/\n/g, ' ');
                prompt += `${idx + 1}. ${preview}...\n`;
            });
            prompt += `\n‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ◊¶◊ï◊® ◊û◊©◊î◊ï ◊©◊ï◊†◊î ◊ú◊ó◊ú◊ï◊ò◊ô◊ü:\n`;
            prompt += `- ◊î◊ß◊©◊® ◊©◊ï◊†◊î\n`;
            prompt += `- ◊û◊°◊§◊®◊ô◊ù ◊©◊ï◊†◊ô◊ù\n`;
            prompt += `- ◊ñ◊ï◊ï◊ô◊™ ◊í◊ô◊©◊î ◊©◊ï◊†◊î\n`;
            prompt += `- ◊†◊ï◊°◊ó ◊©◊ï◊†◊î\n`;
            prompt += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
        }

        // üî• FIX 3: GEOMETRY RULES (if applicable)
        if (classification.isPureGeometry) {
            prompt += `üìê ◊í◊ê◊ï◊û◊ò◊®◊ô◊î ◊ò◊î◊ï◊®◊î - ◊ó◊ï◊ë◊î:\n`;
            prompt += `‚úì ◊î◊™◊ó◊ú ◊ë"◊†◊™◊ï◊ü/◊†◊™◊ï◊†◊î/◊†◊™◊ï◊†◊ô◊ù"\n`;
            prompt += `‚úì ◊ê◊°◊ï◊® ◊î◊ß◊©◊®◊ô◊ù ◊û◊î◊ó◊ô◊ô◊ù ◊î◊ê◊û◊ô◊™◊ô◊ô◊ù\n`;
            prompt += `‚úì ◊ì◊ï◊í◊û◊ê◊ï◊™: "◊†◊™◊ï◊ü ◊û◊ô◊©◊ï◊® Œ±", "◊†◊™◊ï◊†◊ï◊™ ◊†◊ß◊ï◊ì◊ï◊™ A, B"\n\n`;
        }

        if (classification.isAppliedGeometry) {
            prompt += `üìè ◊í◊ê◊ï◊û◊ò◊®◊ô◊î ◊ô◊ô◊©◊ï◊û◊ô◊™:\n`;
            prompt += `‚úì ◊î◊™◊ó◊ú: "◊†◊™◊ï◊ü ◊û◊©◊ï◊ú◊©...", "◊†◊™◊ï◊ü ◊®◊ô◊ë◊ï◊¢..."\n`;
            prompt += `‚úì ◊©◊ê◊ú ◊¢◊ú: ◊©◊ò◊ó, ◊î◊ô◊ß◊£, ◊í◊ï◊ë◊î, ◊¶◊ú◊¢\n\n`;

            prompt += `üö® ◊ó◊ï◊ß◊ô◊ù ◊ú◊û◊©◊ï◊ú◊©◊ô◊ù:\n`;
            prompt += `‚Ä¢ ◊û◊©◊ï◊ú◊© ◊©◊ï◊ï◊î-◊©◊ï◊ß◊ô◊ô◊ù: ◊®◊ß ◊ë◊°◊ô◊° + ◊©◊ï◊ß◊ô◊ô◊ù (2 ◊û◊°◊§◊®◊ô◊ù)\n`;
            prompt += `  ‚ùå ◊ê◊°◊ï◊® ◊ú◊™◊™ ◊í◊ï◊ë◊î!\n`;
            prompt += `  ‚úÖ "◊†◊™◊ï◊ü ◊û◊©◊ï◊ú◊© ◊©◊ï◊ï◊î-◊©◊ï◊ß◊ô◊ô◊ù, ◊ë◊°◊ô◊° 12, ◊©◊ï◊ß◊ô◊ô◊ù 15"\n`;
            prompt += `‚Ä¢ ◊û◊©◊ï◊ú◊© ◊ô◊©◊®-◊ñ◊ï◊ï◊ô◊™: ◊©◊†◊ô ◊†◊ô◊¶◊ë◊ô◊ù\n`;
            prompt += `‚Ä¢ ◊û◊©◊ï◊ú◊© ◊õ◊ú◊ú◊ô: ◊ë◊°◊ô◊° + ◊í◊ï◊ë◊î (◊û◊ï◊™◊®)\n\n`;
        }

        // üî• FIX 4: FILTER EXAMPLES AGGRESSIVELY
        if (personalitySystem.loaded) {
            const topicGuideline = personalitySystem.getTopicGuideline(topicName);
            if (topicGuideline?.curriculum_requirements) {
                prompt += `üìö ◊ì◊®◊ô◊©◊ï◊™ ◊™◊õ◊†◊ô◊™ ◊ú◊ô◊û◊ï◊ì◊ô◊ù:\n${topicGuideline.curriculum_requirements}\n\n`;
            }

            try {
                let examples = personalitySystem.getExamplesForTopic(topicName, difficulty);

                if (examples && examples.length > 0) {
                    // üî• AGGRESSIVE FILTERING
                    const isTriangleTopic = topicName.includes('◊û◊©◊ï◊ú◊©') || topicName.includes('triangle') ||
                        topicName.includes('◊í◊ê◊ï◊û◊ò◊®◊ô◊î') || subtopicName.includes('◊û◊©◊ï◊ú◊©');

                    if (isTriangleTopic) {
                        console.log('   üîç Filtering triangle examples...');

                        examples = examples.filter(ex => {
                            const q = String(ex?.question || '');
                            if (!q) return false;

                            const isIsosceles = /◊©◊ï◊ï◊î[- ]?◊©◊ï◊ß◊ô◊ô◊ù|isosceles/i.test(q);
                            if (!isIsosceles) return true;

                            // Reject if mentions height as given
                            const badPatterns = [
                                /◊ê◊ù\s+◊í◊ï◊ë◊î/i,
                                /◊ï◊í◊ï◊ë◊î\s+◊î◊û◊©◊ï◊ú◊©/i,
                                /◊í◊ï◊ë◊î\s+◊î◊û◊©◊ï◊ú◊©\s+(?:◊ú◊ë◊°◊ô◊°\s+)?(?:◊î◊ï◊ê|◊î◊ô◊†◊ï)\s+\d+/i,
                                /,\s*◊í◊ï◊ë◊î\s+\d+/i,
                                /\.\s*◊í◊ï◊ë◊î\s+\d+/i
                            ];

                            const isBad = badPatterns.some(p => p.test(q));
                            if (isBad) {
                                console.log('   ‚ùå Filtered:', q.substring(0, 60));
                                return false;
                            }
                            return true;
                        });

                        console.log(`   üìä ${examples.length} examples after filtering`);
                    }

                    // üî• ALSO FILTER BY RECENT QUESTIONS
                    if (recentQuestions && recentQuestions.length > 0) {
                        examples = examples.filter(ex => {
                            const exQ = String(ex?.question || '').toLowerCase();
                            return !recentQuestions.some(recent => {
                                const recentQ = recent.question.toLowerCase();
                                // Check for similar context/numbers
                                const exNums = exQ.match(/\d+/g) || [];
                                const recentNums = recentQ.match(/\d+/g) || [];
                                const numOverlap = exNums.filter(n => recentNums.includes(n)).length;
                                return numOverlap > 2; // More than 2 same numbers = too similar
                            });
                        });
                    }

                    if (examples.length > 0) {
                        const shuffled = examples.sort(() => 0.5 - Math.random());
                        const selected = shuffled.slice(0, Math.min(2, examples.length));

                        prompt += `üìö ◊°◊í◊†◊ï◊†◊ï◊™ ◊ú◊ì◊ï◊í◊û◊î (◊¶◊ï◊® ◊û◊©◊î◊ï ◊©◊ï◊†◊î!):\n`;
                        selected.forEach((ex, i) => {
                            prompt += `${i + 1}. ${ex.question}\n`;
                        });
                        prompt += `\n‚ö†Ô∏è ◊î◊©◊ê◊ú◊î ◊©◊ú◊ö ◊ó◊ô◊ô◊ë◊™ ◊ú◊î◊ô◊ï◊™ ◊ô◊ô◊ó◊ï◊ì◊ô◊™ ◊ú◊í◊û◊®◊ô!\n`;

                        if (isTriangleTopic) {
                            prompt += `\nüö® ◊ú◊û◊©◊ï◊ú◊© ◊©◊ï◊ï◊î-◊©◊ï◊ß◊ô◊ô◊ù:\n`;
                            prompt += `◊í◊ù ◊ê◊ù ◊ê◊™◊î ◊®◊ï◊ê◊î ◊ì◊ï◊í◊û◊ê◊ï◊™ ◊ô◊©◊†◊ï◊™ ◊¢◊ù "◊í◊ï◊ë◊î" - ◊ê◊ú ◊™◊ó◊ß◊î!\n`;
                            prompt += `◊î◊©◊™◊û◊© ◊®◊ß: "◊ë◊°◊ô◊° X, ◊©◊ï◊ß◊ô◊ô◊ù Y" (2 ◊û◊°◊§◊®◊ô◊ù)\n`;
                        }
                        prompt += `\n`;
                    } else {
                        console.log('   ‚ö†Ô∏è All examples filtered out - creating fresh');
                    }
                }
            } catch (exampleError) {
                console.error('‚ö†Ô∏è Error loading examples:', exampleError.message);
            }
        }

        // üî• FIX 5: ADD VARIATION STRATEGIES
        if (!classification.isPureGeometry) {
            const strategies = [
                '◊í◊ô◊©◊î ◊û◊™◊û◊ò◊ô◊™ ◊ò◊î◊ï◊®◊î: "◊†◊™◊ï◊ü..."',
                '◊°◊ô◊§◊ï◊® ◊û◊î◊ó◊ô◊ô◊ù: ◊ë◊ô◊™ ◊°◊§◊®, ◊°◊§◊ï◊®◊ò, ◊ß◊†◊ô◊ï◊™',
                '◊ê◊™◊í◊® ◊®◊ë-◊©◊ú◊ë◊ô',
                '◊í◊ô◊ú◊ï◊ô ◊™◊ë◊†◊ô◊™',
                '◊î◊©◊ï◊ï◊ê◊î ◊ë◊ô◊ü ◊û◊¶◊ë◊ô◊ù'
            ];
            const randomStrategy = strategies[Math.floor(Math.random() * strategies.length)];
            prompt += `üé≤ ◊ê◊°◊ò◊®◊ò◊í◊ô◊î: ${randomStrategy}\n`;
            prompt += `üî¢ ◊î◊©◊™◊û◊© ◊ë◊û◊°◊§◊®◊ô◊ù ◊û◊¢◊†◊ô◊ô◊†◊ô◊ù ◊ï◊û◊í◊ï◊ï◊†◊ô◊ù\n\n`;
        }

        // Statistics requirements
        if (classification.isStatistics) {
            prompt += `üìä ◊†◊™◊ï◊†◊ô◊ù ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ô◊ù:\n`;
            prompt += `‚úÖ ◊ú◊§◊ó◊ï◊™ 20 ◊†◊ß◊ï◊ì◊ï◊™ ◊û◊ô◊ì◊¢\n`;
            prompt += `‚úÖ ◊§◊ï◊®◊û◊ò: "◊û◊©◊™◊†◊î X: 12, 15, 18, 21...\n`;
            prompt += `          ◊û◊©◊™◊†◊î Y: 45, 52, 48, 55..."\n\n`;
        }

        // JSON format
        prompt += `\nüö® ◊§◊ï◊®◊û◊ò JSON ◊ó◊ï◊ë◊î:\n`;
        prompt += `{\n`;
        prompt += `  "question": "◊î◊©◊ê◊ú◊î (◊ú◊ú◊ê ◊©◊ï◊®◊ï◊™ ◊ó◊ì◊©◊ï◊™ ◊ê◊û◊ô◊™◊ô◊ï◊™)",\n`;
        prompt += `  "correctAnswer": "◊î◊™◊©◊ï◊ë◊î",\n`;
        prompt += `  "hints": ["◊®◊û◊ñ 1", "◊®◊û◊ñ 2", "◊®◊û◊ñ 3"],\n`;
        prompt += `  "explanation": "◊î◊°◊ë◊®"\n`;
        prompt += `}\n`;
        prompt += `‚Ä¢ ◊î◊©◊™◊û◊© ◊ë-\\n ◊ú◊©◊ï◊®◊î ◊ó◊ì◊©◊î, ◊ú◊ê Enter\n`;
        prompt += `‚Ä¢ ◊ë◊ì◊ï◊ß ◊©◊ê◊ô◊ü ◊§◊°◊ô◊ß◊ô◊ù ◊û◊ô◊ï◊™◊®◊ô◊ù\n`;
        prompt += `‚Ä¢ ◊î◊ó◊ñ◊® ◊®◊ß JSON, ◊ú◊ú◊ê ◊ò◊ß◊°◊ò ◊†◊ï◊°◊£\n\n`;

        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log('üìù PROMPT READY');
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
        console.log(prompt);
        return prompt;

    } catch (error) {
        console.error('‚ùå FATAL ERROR in buildDynamicQuestionPrompt:', error);
        throw new Error(`buildDynamicQuestionPrompt failed: ${error.message}`);
    }
}
// ==================== GENERATE QUESTION ENDPOINT ====================
// ==================== GENERATE QUESTION ENDPOINT WITH RETRY LOGIC ====================
app.post('/api/ai/generate-question', async (req, res) => {
    try {
        const { topic, subtopic, difficulty, studentProfile } = req.body;

        if (!topic || !topic.name) {
            return res.status(400).json({
                success: false,
                error: 'Invalid topic object'
            });
        }

        if (!studentProfile || !studentProfile.grade) {
            return res.status(400).json({
                success: false,
                error: 'Invalid student profile'
            });
        }

        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log('üìù SMART QUESTION GENERATION');
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log('   Topic:', topic.name);
        console.log('   Subtopic:', subtopic?.name || 'General');

        const gradeId = `grade_${studentProfile.grade}`;
        const studentId = studentProfile.studentId || studentProfile.name || 'anonymous';

        let prompt = buildDynamicQuestionPrompt(topic, subtopic, difficulty, studentProfile, gradeId);
        const systemPrompt = buildEnhancedSystemPrompt(studentProfile, gradeId, topic, subtopic);

        let attempts = 0;
        let parsed;
        const maxAttempts = 3;

        while (attempts < maxAttempts) {
            attempts++;

            if (process.env.ANTHROPIC_API_KEY) {
                console.log(`   üîÑ Attempt ${attempts}/${maxAttempts}`);

                // üî• RETRY LOGIC WITH EXPONENTIAL BACKOFF
                let apiSuccess = false;
                let lastError = null;

                for (let retryAttempt = 0; retryAttempt < 3; retryAttempt++) {
                    try {
                        // Wait before retry (exponential backoff: 2s, 4s, 8s)
                        if (retryAttempt > 0) {
                            const waitTime = Math.pow(2, retryAttempt) * 1000;
                            console.log(`   ‚è≥ API Retry ${retryAttempt}/3 - waiting ${waitTime}ms...`);
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                        }

                        const response = await fetch('https://api.anthropic.com/v1/messages', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-api-key': process.env.ANTHROPIC_API_KEY,
                                'anthropic-version': '2023-06-01'
                            },
                            body: JSON.stringify({
                                model: 'claude-3-5-haiku-20241022',
                                max_tokens: 3000,
                                temperature: 0.8 + (attempts * 0.1),
                                system: systemPrompt,
                                messages: [{ role: 'user', content: prompt }]
                            })
                        });

                        const data = await response.json();

                        // Handle 529 Overloaded error
                        if (response.status === 529) {
                            lastError = new Error('Overloaded');
                            console.log(`   ‚ö†Ô∏è API Overloaded (retry ${retryAttempt + 1}/3)`);
                            continue; // Try again
                        }

                        // Handle other errors
                        if (!response.ok) {
                            lastError = new Error(data.error?.message || `API error: ${response.status}`);
                            console.log(`   ‚ùå API Error: ${lastError.message}`);

                            // If it's a rate limit or server error, retry
                            if (response.status >= 500 || response.status === 429) {
                                continue;
                            }

                            // For other errors (like auth), don't retry
                            throw lastError;
                        }

                        // Success! Parse the response
                        const rawText = data.content[0].text;
                        const jsonText = cleanJsonText(rawText);
                        parsed = JSON.parse(jsonText);

                        console.log('   ‚úÖ API call successful');
                        apiSuccess = true;
                        break; // Exit retry loop

                    } catch (error) {
                        lastError = error;
                        console.error(`   ‚ùå API attempt ${retryAttempt + 1} failed:`, error.message);

                        // If it's the last retry attempt, throw
                        if (retryAttempt === 2) {
                            throw error;
                        }

                        // Otherwise, continue to next retry
                    }
                }

                // If all retries failed, throw the last error
                if (!apiSuccess) {
                    throw lastError || new Error('All API retry attempts failed');
                }

                console.log('   ‚úÖ Parsed successfully');

                // Check for similarity with recent questions
                const topicId = topic.id || topic.name;
                const recentQuestions = questionHistoryManager.getRecentQuestions(studentId, topicId, 5);
                const isSimilar = questionHistoryManager.isSimilar(parsed.question, recentQuestions);

                if (isSimilar && attempts < maxAttempts) {
                    console.log(`   ‚ö†Ô∏è Too similar, retrying...`);
                    prompt += `\n\nüö® TOO SIMILAR! Create MORE DIFFERENT!\n`;
                    continue;
                } else {
                    console.log('   ‚úÖ Question is unique');
                    break;
                }
            } else {
                throw new Error('No AI API configured');
            }
        }

        // Validate and process the question
        const validation = validateQuestionHasRawData(parsed, topic, subtopic);
        if (!validation.valid) {
            console.log('   ‚ö†Ô∏è Validation failed - rewriting');
            parsed = forceRewriteGraphDescription(parsed, topic, subtopic);
        }

        parsed = ensureVisualDataForGraphQuestions(parsed, topic, subtopic);
        parsed = detectGeometryVisual(parsed, topic, subtopic);

        if (parsed.visualData?.type?.startsWith('svg-')) {
            const svgType = parsed.visualData.type.replace('svg-', '');
            let svg = null;

            try {
                if (svgType === 'triangle') {
                    svg = SVGGenerator.generateTriangle(parsed.visualData.svgData);
                } else if (svgType === 'rectangle') {
                    svg = SVGGenerator.generateRectangle(parsed.visualData.svgData);
                } else if (svgType === 'circle') {
                    svg = SVGGenerator.generateCircle(parsed.visualData.svgData);
                }

                if (svg) {
                    parsed.visualData.svg = svg;
                    console.log('   ‚úÖ SVG generated:', svgType);
                }
            } catch (svgError) {
                console.error('   ‚ùå SVG error:', svgError);
            }
        }

        const topicId = topic.id || topic.name;
        questionHistoryManager.addQuestion(studentId, topicId, {
            question: parsed.question,
            timestamp: Date.now()
        });

        console.log('   ‚úÖ Complete');
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');

        return res.json({
            success: true,
            question: {
                question: parsed.question,
                correctAnswer: parsed.correctAnswer,
                hints: parsed.hints || [],
                explanation: parsed.explanation || '',
                topic: topic.name,
                subtopic: subtopic?.name,
                difficulty: parsed.difficulty || difficulty,
                gradeLevel: studentProfile.grade,
                visualData: parsed.visualData || null,
                curriculumAligned: true,
                reformYear: CURRICULUM_METADATA.reformYear
            },
            model: 'claude-3.5-haiku',
            personalityActive: personalitySystem.loaded,
            attemptCount: attempts
        });

    } catch (error) {
        console.error('‚ùå Error:', error);

        // Provide user-friendly error messages
        let errorMessage = error.message;
        if (error.message === 'Overloaded') {
            errorMessage = '◊î◊©◊®◊™ ◊¢◊û◊ï◊° ◊õ◊®◊í◊¢. ◊ê◊†◊ê ◊†◊°◊î ◊©◊ï◊ë ◊ë◊¢◊ï◊ì ◊õ◊û◊î ◊©◊†◊ô◊ï◊™.';
        }

        res.status(500).json({
            success: false,
            error: errorMessage
        });
    }
});
// ==================== VERIFY ANSWER ====================


// Replace your existing endpoint with this:
app.post('/api/ai/verify-answer', async (req, res) => {
    try {
        const { question, userAnswer, correctAnswer, studentName, topic, subtopic, userId } = req.body;

        console.log('üîç VERIFYING ANSWER');

        let isCorrect = false;
        let feedback = '';
        let explanation = '';
        let confidence = 0;
        let model = '';

        // Check for exact match first
        if (compareMathExpressions(userAnswer, correctAnswer)) {
            console.log('‚úÖ EXACT MATCH');

            isCorrect = true;
            confidence = 100;
            feedback = '◊†◊õ◊ï◊ü ◊û◊¶◊ï◊ô◊ü! üéâ';
            explanation = '◊î◊™◊©◊ï◊ë◊î ◊©◊ú◊ö ◊†◊õ◊ï◊†◊î!';
            model = 'exact-match';

        } else {
            // Use AI verification
            const prompt = `◊ë◊ì◊ï◊ß:\n\n◊©◊ê◊ú◊î: ${question}\n◊™◊ú◊û◊ô◊ì: ${userAnswer}\n◊†◊õ◊ï◊ü: ${correctAnswer}\n\nJSON:\n{"isCorrect":true/false,"feedback":"...","explanation":"..."}`;

            if (process.env.ANTHROPIC_API_KEY) {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': process.env.ANTHROPIC_API_KEY,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-5-haiku-20241022',
                        max_tokens: 1500,
                        temperature: 0.3,
                        system: '◊ê◊™◊î ◊†◊ß◊°◊ï◊ü. ◊ë◊ì◊ï◊ß ◊©◊ß◊ô◊ú◊ï◊™ ◊û◊™◊û◊ò◊ô◊™. JSON ◊ë◊ú◊ë◊ì.',
                        messages: [{ role: 'user', content: prompt }]
                    })
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error?.message || 'API error');
                }

                const rawText = data.content[0].text;
                const jsonText = cleanJsonText(rawText);
                const parsed = JSON.parse(jsonText);

                isCorrect = parsed.isCorrect;
                confidence = 95;
                feedback = parsed.feedback;
                explanation = parsed.explanation;
                model = 'claude-3.5-haiku';
            } else {
                throw new Error('No AI configured');
            }
        }

        // ‚ú® AUTO-SAVE TO NOTEBOOK IF CORRECT
        if (isCorrect && userId) {
            try {
                console.log('üìì Saving to notebook...');
                await notebookService.saveExerciseToNotebook(userId, {
                    question: question,
                    answer: correctAnswer,
                    studentAnswer: userAnswer,
                    isCorrect: true,
                    topic: topic || '◊õ◊ú◊ú◊ô',
                    subtopic: subtopic || ''
                });
                console.log('‚úÖ Saved to notebook successfully');
            } catch (notebookError) {
                // Don't fail the request if notebook save fails
                console.error('‚ö†Ô∏è Failed to save to notebook:', notebookError.message);
                // Continue anyway - the answer verification is still valid
            }
        }

        // Return the verification result
        return res.json({
            success: true,
            isCorrect,
            confidence,
            feedback,
            explanation,
            model
        });

    } catch (error) {
        console.error('‚ùå Error:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});
// ==================== GET HINT ====================

// ==================== ADMIN: UPLOAD PERSONALITY FILE ====================
app.post('/api/admin/upload-personality', upload.single('file'), async (req, res) => {
    try {
        console.log('üì§ PERSONALITY FILE UPLOAD');

        if (!req.file) {
            return res.status(400).json({
                success: false,
                error: 'No file uploaded'
            });
        }

        console.log('   File:', req.file.originalname);
        console.log('   Size:', req.file.size, 'bytes');

        // Save to local uploads directory
        const uploadsDir = path.join(__dirname, '../uploads');
        if (!fs.existsSync(uploadsDir)) {
            fs.mkdirSync(uploadsDir, { recursive: true });
        }

        const localPath = path.join(uploadsDir, 'personality-system.xlsx');
        fs.writeFileSync(localPath, req.file.buffer);
        console.log('   ‚úÖ Saved locally:', localPath);

        // Upload to Firebase Storage if available
        if (bucket) {
            const file = bucket.file('personality-system.xlsx');
            await file.save(req.file.buffer, {
                metadata: {
                    contentType: req.file.mimetype,
                    metadata: {
                        uploadedAt: new Date().toISOString()
                    }
                }
            });
            console.log('   ‚úÖ Uploaded to Firebase Storage');
        } else {
            console.log('   ‚ö†Ô∏è Firebase not configured - local only');
        }

        // Reload personality system
        personalitySystem.loadFromExcel(localPath);
        console.log('   ‚úÖ Personality system reloaded');

        res.json({
            success: true,
            message: 'Personality file uploaded and loaded successfully',
            filename: req.file.originalname,
            size: req.file.size,
            firebaseUploaded: !!bucket,
            personalityLoaded: personalitySystem.loaded
        });

    } catch (error) {
        console.error('‚ùå Upload error:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/api/ai/get-hint', async (req, res) => {
    try {
        const { question, hintIndex } = req.body;

        const hintLevels = ['◊®◊û◊ñ ◊¢◊ì◊ô◊ü', '◊®◊û◊ñ ◊ô◊©◊ô◊®', '◊®◊û◊ñ ◊°◊§◊¶◊ô◊§◊ô'];
        const prompt = `◊™◊ü ${hintLevels[hintIndex]} ◊ú◊©◊ê◊ú◊î:\n\n${question}`;

        if (process.env.ANTHROPIC_API_KEY) {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': process.env.ANTHROPIC_API_KEY,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-3-5-haiku-20241022',
                    max_tokens: 500,
                    temperature: 0.7,
                    messages: [{ role: 'user', content: prompt }]
                })
            });

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error?.message || 'API error');
            }

            return res.json({
                success: true,
                hint: data.content[0].text
            });
        }

        throw new Error('No AI configured');

    } catch (error) {
        console.error('‚ùå Error:', error);
        res.json({
            success: true,
            hint: '◊†◊°◊î ◊ú◊§◊®◊ß ◊ê◊™ ◊î◊©◊ê◊ú◊î ü§î'
        });
    }
});

// ==================== AI CHAT ====================
app.post('/api/ai/chat', async (req, res) => {
    try {
        const { message, context } = req.body;

        const wantsFullSolution = /◊§◊™◊®◊ï◊ü|◊î◊®◊ê◊î|◊©◊ú◊ë/i.test(message);

        let conversationPrompt = wantsFullSolution
            ? `◊™◊ü ◊§◊™◊®◊ï◊ü ◊û◊§◊ï◊®◊ò ◊ú: ${context?.question}`
            : `◊¢◊ñ◊ï◊®: "${message}"\n\n◊©◊ê◊ú◊î: ${context?.question}`;

        if (process.env.ANTHROPIC_API_KEY) {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': process.env.ANTHROPIC_API_KEY,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-3-5-haiku-20241022',
                    max_tokens: wantsFullSolution ? 2000 : 800,
                    temperature: 0.7,
                    messages: [{ role: 'user', content: conversationPrompt }]
                })
            });

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error?.message || 'API error');
            }

            return res.json({
                success: true,
                response: data.content[0].text,
                model: 'claude-3.5-haiku'
            });
        }

        throw new Error('No AI configured');

    } catch (error) {
        console.error('‚ùå Error:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// ==================== üî• IMAGE ANALYSIS FOR HANDWRITTEN WORK ====================
app.post('/api/ai/analyze-handwritten-work', upload.single('image'), async (req, res) => {
    console.log('\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üì∏ ANALYZING HANDWRITTEN WORK');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');

    try {
        if (!req.file) {
            return res.status(400).json({
                success: false,
                error: 'No image file uploaded'
            });
        }

        const {
            question,
            correctAnswer,
            studentName = '◊™◊ú◊û◊ô◊ì',
            grade = '8',
            topic = '',
            personality = 'nexon',
            mathFeeling = 'okay',
            learningStyle = 'visual'
        } = req.body;

        console.log('   Question:', question?.substring(0, 60) + '...');
        console.log('   Correct Answer:', correctAnswer);
        console.log('   Student:', studentName);
        console.log('   File:', req.file.originalname);
        console.log('   Size:', (req.file.size / 1024).toFixed(2), 'KB');

        if (!question || !correctAnswer) {
            return res.status(400).json({
                success: false,
                error: 'Missing required fields: question and correctAnswer'
            });
        }

        // Get base64 image from buffer
        const base64Image = req.file.buffer.toString('base64');

        // Determine media type
        const mediaTypeMap = {
            'image/jpeg': 'image/jpeg',
            'image/jpg': 'image/jpeg',
            'image/png': 'image/png',
            'image/webp': 'image/webp',
            'image/gif': 'image/gif'
        };
        const mediaType = mediaTypeMap[req.file.mimetype] || 'image/jpeg';

        console.log('   Media Type:', mediaType);

        // Build personality context
        let personalityContext = '◊ê◊™◊î ◊†◊ß◊°◊ï◊ü - ◊û◊ï◊®◊î ◊ì◊ô◊í◊ô◊ò◊ú◊ô ◊ô◊ì◊ô◊ì◊ï◊™◊ô, ◊ê◊ï◊§◊ò◊ô◊û◊ô ◊ï◊û◊¢◊ï◊ì◊ì. ◊î◊©◊™◊û◊© ◊ë◊ê◊ô◊û◊ï◊í◊≥◊ô◊ù ◊ï◊î◊ô◊î ◊ó◊ô◊ï◊ë◊ô.';

        if (personalitySystem.loaded) {
            const corePersonality = personalitySystem.data.corePersonality;
            personalityContext = `◊ê◊™◊î ${corePersonality.teacher_name}, ${corePersonality.description}. ${corePersonality.teaching_approach}`;
        }

        // Student feeling context
        let feelingContext = '';
        if (mathFeeling === 'struggle') {
            feelingContext = '◊î◊™◊ú◊û◊ô◊ì ◊û◊™◊ß◊©◊î - ◊î◊ô◊î ◊°◊ë◊ú◊†◊ô ◊û◊ê◊ï◊ì ◊ï◊û◊¢◊ï◊ì◊ì.';
        } else if (mathFeeling === 'love') {
            feelingContext = '◊î◊™◊ú◊û◊ô◊ì ◊ê◊ï◊î◊ë ◊û◊™◊û◊ò◊ô◊ß◊î - ◊¢◊ï◊ì◊ì ◊ê◊ï◊™◊ï ◊ú◊î◊û◊©◊ô◊ö!';
        }

        const analysisPrompt = `${personalityContext}

${feelingContext ? feelingContext + '\n' : ''}
◊ê◊™◊î ◊ë◊ï◊ì◊ß ◊ê◊™ ◊î◊§◊™◊®◊ï◊ü ◊ë◊õ◊™◊ë ◊ô◊ì ◊©◊ú ${studentName} (◊õ◊ô◊™◊î ${grade}).
${topic ? `◊†◊ï◊©◊ê: ${topic}\n` : ''}

**◊î◊©◊ê◊ú◊î ◊î◊û◊ß◊ï◊®◊ô◊™:**
${question}

**◊î◊™◊©◊ï◊ë◊î ◊î◊†◊õ◊ï◊†◊î:**
${correctAnswer}

**◊î◊û◊©◊ô◊û◊î ◊©◊ú◊ö:**
1. ◊ñ◊î◊î ◊ê◊™ ◊î◊™◊©◊ï◊ë◊î ◊î◊°◊ï◊§◊ô◊™ ◊©◊î◊™◊ú◊û◊ô◊ì ◊õ◊™◊ë ◊ë◊™◊û◊ï◊†◊î
2. ◊ë◊ì◊ï◊ß ◊ê◊ù ◊î◊™◊©◊ï◊ë◊î ◊†◊õ◊ï◊†◊î (◊î◊©◊ï◊ï◊î ◊ú◊™◊©◊ï◊ë◊î ◊î◊†◊õ◊ï◊†◊î)
3. ◊†◊™◊ó ◊ê◊™ ◊î◊©◊ú◊ë◊ô◊ù ◊©◊î◊™◊ú◊û◊ô◊ì ◊ë◊ô◊¶◊¢ (◊ê◊ù ◊†◊®◊ê◊ô◊ù)
4. ◊™◊ü ◊û◊©◊ï◊ë ◊û◊¢◊ï◊ì◊ì ◊ï◊û◊ï◊¢◊ô◊ú ◊ë◊¢◊ë◊®◊ô◊™

**◊ó◊©◊ï◊ë ◊û◊ê◊ï◊ì:**
- ◊ê◊ù ◊î◊™◊ú◊û◊ô◊ì ◊§◊™◊® ◊©◊ê◊ú◊î ◊ê◊ó◊®◊™ (◊ú◊ê ◊ê◊™ ◊î◊©◊ê◊ú◊î ◊î◊û◊ß◊ï◊®◊ô◊™), ◊¶◊ô◊ô◊ü ◊ñ◊ê◊™ ◊ë◊û◊§◊ï◊®◊©!
- ◊î◊™◊¢◊ú◊ù ◊û◊î◊ë◊ì◊ú◊ô◊ù ◊ß◊ú◊ô◊ù ◊ë◊õ◊™◊ô◊ë (◊ú◊û◊©◊ú: 42 ◊ñ◊î◊î ◊ú-42.0, 1/2 ◊ñ◊î◊î ◊ú-0.5)
- ◊ê◊ù ◊ê◊™◊î ◊®◊ï◊ê◊î ◊®◊ß ◊™◊©◊ï◊ë◊î ◊°◊ï◊§◊ô◊™ ◊ú◊ú◊ê ◊©◊ú◊ë◊ô◊ù, ◊ñ◊î ◊ë◊°◊ì◊® - ◊†◊™◊ó ◊û◊î ◊©◊ê◊™◊î ◊®◊ï◊ê◊î
- ◊î◊ô◊î ◊°◊ë◊ú◊†◊ô ◊ï◊ó◊ô◊ï◊ë◊ô - ◊ñ◊î ◊™◊ú◊û◊ô◊ì ◊©◊û◊†◊°◊î!

◊î◊©◊ë ◊ë◊û◊ë◊†◊î JSON ◊î◊ë◊ê (◊ë◊ì◊ô◊ï◊ß ◊õ◊ö):
{
  "detectedAnswer": "◊î◊™◊©◊ï◊ë◊î ◊î◊û◊ì◊ï◊ô◊ß◊™ ◊©◊ñ◊ô◊î◊ô◊™ ◊û◊î◊™◊û◊ï◊†◊î (◊ò◊ß◊°◊ò)",
  "isCorrect": true ◊ê◊ï false,
  "matchesQuestion": true ◊ê◊ï false (◊î◊ê◊ù ◊î◊™◊ú◊û◊ô◊ì ◊§◊™◊® ◊ê◊™ ◊î◊©◊ê◊ú◊î ◊î◊†◊õ◊ï◊†◊î),
  "feedback": "◊û◊©◊ï◊ë ◊û◊§◊ï◊®◊ò ◊ë◊¢◊ë◊®◊ô◊™ ◊¢◊ù ◊ê◊ô◊û◊ï◊í'◊ô◊ù - ◊¢◊ï◊ì◊ì ◊ê◊™ ◊î◊™◊ú◊û◊ô◊ì ◊ï◊™◊ü ◊ò◊ô◊§◊ô◊ù",
  "stepsAnalysis": ["◊©◊ú◊ë 1 ◊©◊î◊™◊ú◊û◊ô◊ì ◊ë◊ô◊¶◊¢", "◊©◊ú◊ë 2...", "◊©◊ú◊ë 3..."] ◊ê◊ï [] ◊ê◊ù ◊ú◊ê ◊†◊®◊ê◊ô◊ù ◊©◊ú◊ë◊ô◊ù
}

◊ê◊ù ◊ú◊ê ◊û◊¶◊ê◊™ ◊§◊™◊®◊ï◊ü ◊ë◊™◊û◊ï◊†◊î ◊ê◊ï ◊©◊î◊™◊û◊ï◊†◊î ◊ú◊ê ◊ë◊®◊ï◊®◊î, ◊¶◊ô◊ô◊ü ◊ñ◊ê◊™ ◊ë-feedback ◊ï-detectedAnswer ◊ô◊î◊ô◊î ◊®◊ô◊ß.
◊î◊ó◊ñ◊® **◊®◊ß JSON** - ◊ú◊ú◊ê ◊ò◊ß◊°◊ò ◊†◊ï◊°◊£ ◊ú◊§◊†◊ô ◊ê◊ï ◊ê◊ó◊®◊ô!`;

        console.log('   üì§ Sending to Claude Sonnet Vision API...');

        // üî• RETRY LOGIC WITH EXPONENTIAL BACKOFF
        let apiSuccess = false;
        let claudeResponse = null;
        let lastError = null;

        for (let retryAttempt = 0; retryAttempt < 3; retryAttempt++) {
            try {
                // Wait before retry (exponential backoff: 2s, 4s, 8s)
                if (retryAttempt > 0) {
                    const waitTime = Math.pow(2, retryAttempt) * 1000;
                    console.log(`   ‚è≥ API Retry ${retryAttempt}/3 - waiting ${waitTime}ms...`);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }

                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': process.env.ANTHROPIC_API_KEY,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-5-haiku-20241022',  // ‚úÖ MUST USE SONNET FOR VISION
                        max_tokens: 2000,
                        temperature: 0.5,
                        messages: [{
                            role: 'user',
                            content: [
                                {
                                    type: 'image',
                                    source: {
                                        type: 'base64',
                                        media_type: mediaType,
                                        data: base64Image
                                    }
                                },
                                {
                                    type: 'text',
                                    text: analysisPrompt
                                }
                            ]
                        }]
                    })
                });

                const data = await response.json();

                // Handle 529 Overloaded error
                if (response.status === 529) {
                    lastError = new Error('Overloaded');
                    console.log(`   ‚ö†Ô∏è API Overloaded (retry ${retryAttempt + 1}/3)`);
                    continue;
                }

                // Handle other errors
                if (!response.ok) {
                    lastError = new Error(data.error?.message || `API error: ${response.status}`);
                    console.log(`   ‚ùå API Error: ${lastError.message}`);
                    console.log('   Full error:', JSON.stringify(data, null, 2));

                    // If it's a rate limit or server error, retry
                    if (response.status >= 500 || response.status === 429) {
                        continue;
                    }

                    throw lastError;
                }

                // Success!
                claudeResponse = data;
                console.log('   ‚úÖ API call successful');
                apiSuccess = true;
                break;

            } catch (error) {
                lastError = error;
                console.error(`   ‚ùå API attempt ${retryAttempt + 1} failed:`, error.message);

                if (retryAttempt === 2) {
                    throw error;
                }
            }
        }

        if (!apiSuccess) {
            throw lastError || new Error('All API retry attempts failed');
        }

        // Parse Claude's response
        const claudeText = claudeResponse.content[0].text;
        console.log('   üì• Raw response (first 200):', claudeText.substring(0, 200));

        // Extract JSON from response
        let analysis;
        try {
            const jsonText = cleanJsonText(claudeText);
            analysis = JSON.parse(jsonText);
            console.log('   ‚úÖ JSON parsed successfully');
        } catch (parseError) {
            console.error('   ‚ùå JSON parse error:', parseError.message);

            // Fallback analysis
            analysis = {
                detectedAnswer: '',
                isCorrect: false,
                matchesQuestion: true,
                feedback: claudeText.includes('◊ú◊ê') ? claudeText : '◊ú◊ê ◊î◊¶◊ú◊ó◊™◊ô ◊ú◊†◊™◊ó ◊ê◊™ ◊î◊™◊û◊ï◊†◊î ◊ë◊¶◊ï◊®◊î ◊û◊ú◊ê◊î. ◊†◊°◊î ◊ú◊¶◊ú◊ù ◊©◊ï◊ë ◊¢◊ù ◊™◊ê◊ï◊®◊î ◊ò◊ï◊ë◊î ◊ô◊ï◊™◊®! üì∏',
                stepsAnalysis: []
            };
        }

        // Validate and clean analysis
        const cleanedAnalysis = {
            detectedAnswer: String(analysis.detectedAnswer || '').trim(),
            isCorrect: Boolean(analysis.isCorrect),
            matchesQuestion: analysis.matchesQuestion !== false,
            feedback: String(analysis.feedback || '◊ú◊ê ◊î◊¶◊ú◊ó◊™◊ô ◊ú◊†◊™◊ó ◊ê◊™ ◊î◊™◊û◊ï◊†◊î. ◊†◊°◊î ◊©◊ï◊ë! üì∏').trim(),
            stepsAnalysis: Array.isArray(analysis.stepsAnalysis) ? analysis.stepsAnalysis : []
        };

        console.log('   üìä Analysis Result:');
        console.log('      Detected:', cleanedAnalysis.detectedAnswer);
        console.log('      Correct:', cleanedAnalysis.isCorrect ? '‚úÖ' : '‚ùå');
        console.log('      Matches Question:', cleanedAnalysis.matchesQuestion ? '‚úÖ' : '‚ö†Ô∏è');
        console.log('      Steps:', cleanedAnalysis.stepsAnalysis.length);
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');

        // Return analysis
        res.json({
            success: true,
            analysis: cleanedAnalysis,
            model: 'claude-3-5-haiku-20241022',  // ‚úÖ SONNET FOR VISION
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        console.error('‚ùå CRITICAL ERROR:', error);
        console.error('   Error details:', error.message);
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');

        // User-friendly error messages
        let errorMessage = error.message;
        if (error.message === 'Overloaded') {
            errorMessage = '◊î◊©◊®◊™ ◊¢◊û◊ï◊° ◊õ◊®◊í◊¢. ◊ê◊†◊ê ◊†◊°◊î ◊©◊ï◊ë ◊ë◊¢◊ï◊ì ◊õ◊û◊î ◊©◊†◊ô◊ï◊™.';
        } else if (error.message.includes('API key')) {
            errorMessage = '◊©◊í◊ô◊ê◊™ ◊î◊í◊ì◊®◊ï◊™ ◊©◊®◊™. ◊ê◊†◊ê ◊§◊†◊î ◊ú◊û◊†◊î◊ú ◊î◊û◊¢◊®◊õ◊™.';
        } else if (error.message.includes('model')) {
            errorMessage = '◊©◊í◊ô◊ê◊î ◊ë◊û◊ï◊ì◊ú AI. ◊û◊†◊°◊î ◊©◊ï◊ë...';
        }

        res.status(500).json({
            success: false,
            error: errorMessage,
            timestamp: new Date().toISOString()
        });
    }
});

// ==================== START SERVER ====================
async function loadPersonalityFromStorage() {
    if (!bucket) {
        console.log('‚ö†Ô∏è Firebase not configured - using local storage');
        const localPath = path.join(__dirname, '../uploads/personality-system.xlsx');
        if (fs.existsSync(localPath)) {
            personalitySystem.loadFromExcel(localPath);
            console.log('‚úÖ Loaded from local file');
        }
        return;
    }

    try {
        const file = bucket.file('personality-system.xlsx');
        const [exists] = await file.exists();
        if (exists) {
            const tempPath = `/tmp/personality-system.xlsx`;
            await file.download({ destination: tempPath });
            personalitySystem.loadFromExcel(tempPath);
            console.log('‚úÖ Loaded from Firebase');
        }
    } catch (error) {
        console.error('‚ùå Error loading personality:', error.message);
    }
}
app.use('/api/users', userRoutes);

app.use('/api/notebook', notebookRoutes);

app.use('/api/curriculum', curriculumRoutes);

app.use('/api', nexonRoutes);

app.use('/api/learning', learningRoutes);


app.listen(PORT, async () => {
    await loadPersonalityFromStorage();

    console.log('\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üöÄ NEXON AI - SMART TOPIC-BASED QUESTIONS');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log(`üì° Server: http://localhost:${PORT}`);
    console.log(`   ‚Ä¢ Personality: ${personalitySystem.loaded ? '‚úÖ' : '‚ùå'}`);
    console.log(`   ‚Ä¢ Smart Topics: ‚úÖ`);
    console.log(`   ‚Ä¢ SVG Support: ‚úÖ`);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
});